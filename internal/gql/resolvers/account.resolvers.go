package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"fmt"
	"net"
	"os"

	"github.com/Go-Golang-Gorm-Postgres-Gqlgen-Graphql/main/internal/gql/model"
)

// Mutation returns generated.MutationResolver implementation.
// func (r *Resolver) Mutation() generated.MutationResolver {
// 	return &accountResolver{r}
// }

// Mutation returns generated.MutationResolver implementation.
// func (r *Resolver) Query() generated.QueryResolver {
// 	return &queryResolver{r}
// }

type accountResolver struct{ *Resolver }

// type mutationResolver struct{ *Resolver }

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) Register(ctx context.Context, input model.Register) (string, error) {

	// // Hash submitted password
	// passwordHash, err := encrypt.GenHash(input.Password, 14)
	// if err != nil {
	// 	return nil, err
	// }
	// input.Password = passwordHash

	// var user model.User
	// if err := utils.Copy(&user, &input); err != nil {
	// 	return nil, err
	// }

	// if err := r.db.Create(&user).First(&user).Scan(&user).Error; err != nil {
	// 	return nil, err
	// }

	// fmt.Println("input", input)
	// fmt.Println("user", user)

	// return &user, nil
	return "", nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) Login(ctx context.Context, input model.Login) (string, error) {
	conn, err := getUserConnection(nil)
	if err != nil {
		return "", err
	}

	fmt.Println("Login - ctx", &ctx)
	fmt.Println("Login - conn", &conn)
	return "", nil

	// panic(fmt.Errorf("not implemented: Login - login"))
}

// type queryResolver struct{ *Resolver }

// // User is the resolver for the users field.
// func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
// 	fmt.Println("Listing Users")
// 	var users []*model.User

// 	err := r.db.Find(&users).Error
// 	if err != nil {
// 		return nil, err
// 	}

// 	return users, nil
// }

func getUserConnection(ctx context.Context) (net.Conn, error) {
	user_address, ok := os.LookupEnv("USER_SERVICE_ADDRESS")
	fmt.Println("user_address", user_address)
	if !ok {
		panic(fmt.Sprintf("no address specified for %s", user_address))
	}

	conn, err := net.Dial("tcp", user_address)
	if err != nil {
		fmt.Println("getUserConnection", err.Error())
		panic("")
	}
	fmt.Println("conn", conn)

	return conn, nil

	// var dialOpts []grpc.DialOption
	// dialOpts = append(dialOpts, grpc.WithTransportCredentials(insecure.NewCredentials()))

	// userServiceEndpoint, ok := os.LookupEnv("USER_SERVICE_ADDRESS")
	// if !ok {
	// 	logger.Panic(
	// 		"failed to find USER_SERVICE_ADDRESS environment variable",
	// 	)
	// }

	// conn, err := grpc.Dial(userServiceEndpoint, dialOpts...)
	// if err != nil {
	// 	return nil, fmt.Errorf("failed to connect to UserService. %s", err.Error())
	// }
	// return userv1.NewUserServiceClient(conn), nil
}
