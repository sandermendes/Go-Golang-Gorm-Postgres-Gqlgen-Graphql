// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/Go-Golang-Gorm-Postgres-Gqlgen-Graphql/main/internal/gql/model"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	DatabaseField func(ctx context.Context, obj interface{}, next graphql.Resolver, fieldName *string) (res interface{}, err error)
}

type ComplexityRoot struct {
	Mutation struct {
		CreateUser func(childComplexity int, input model.NewUser) int
		Login      func(childComplexity int, input model.Login) int
		Register   func(childComplexity int, input model.Register) int
		UpdateUser func(childComplexity int, input model.UpdateUser) int
	}

	Query struct {
		Users func(childComplexity int) int
	}

	User struct {
		Email     func(childComplexity int) int
		FirstName func(childComplexity int) int
		LastName  func(childComplexity int) int
		Password  func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(model.NewUser)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["input"].(model.Login)), true

	case "Mutation.register":
		if e.complexity.Mutation.Register == nil {
			break
		}

		args, err := ec.field_Mutation_register_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Register(childComplexity, args["input"].(model.Register)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["input"].(model.UpdateUser)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.firstName":
		if e.complexity.User.FirstName == nil {
			break
		}

		return e.complexity.User.FirstName(childComplexity), true

	case "User.lastName":
		if e.complexity.User.LastName == nil {
			break
		}

		return e.complexity.User.LastName(childComplexity), true

	case "User.password":
		if e.complexity.User.Password == nil {
			break
		}

		return e.complexity.User.Password(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputLogin,
		ec.unmarshalInputNewUser,
		ec.unmarshalInputRegister,
		ec.unmarshalInputUpdateUser,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/schema.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Query

type Mutation
`, BuiltIn: false},
	{Name: "../../../microservices/account/schemas/account.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

input Login {
  email: String!
  password: String!
}

input Register {
  firstName: String!
  lastName: String!
  email: String!
  password: String!
}

extend type Mutation {
  register(input: Register!): String!
  login(input: Login!): String!
}

`, BuiltIn: false},
	{Name: "../../../microservices/user/schemas/user.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

scalar UInt64

type User {
    # Base Model added by gqlgen model template: model.gotpl

    # @DatabaseField directive means to, generate command to Gorm structure the data in Database
    #   fieldName, is about a name for cloumn table
    #   custom is about a some another custom column config, eg: "type:uuid;primaryKey;default:gen_random_uuid()",
    #   final code result in struct is like, eg: FirstName string ` + "`" + `gorm:"type:uuid;primaryKey;default:gen_random_uuid()"` + "`" + `
    firstName: String! @DatabaseField(fieldName: "first_name")
    lastName:  String! @DatabaseField(fieldName: "last_name")
    email:    String! @DatabaseField(custom: "not null")
    password: String! @DatabaseField(custom: "not null")
}

extend type Query {
  users: [User!]!
}

input NewUser {
  firstName: String!
  lastName: String!
  email: String!
  password: String!
}

input UpdateUser {
  firstName: String!
}

extend type Mutation {
  createUser(input: NewUser!): User!
  updateUser(input: UpdateUser!): User!
}

`, BuiltIn: false},
	{Name: "../../../directives.graphql", Input: `
			directive @DatabaseField(fieldName: String) on OBJECT | FIELD_DEFINITION
			scalar Time
		`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
