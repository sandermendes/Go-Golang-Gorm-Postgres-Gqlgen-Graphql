package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"

	"github.com/Go-Golang-Gorm-Postgres-Gqlgen-Graphql/main/microservices/graphql/model"
	accountv1 "github.com/Go-Golang-Gorm-Postgres-Gqlgen-Graphql/main/shared/protobufs/_generated/account/v1"
	"github.com/Go-Golang-Gorm-Postgres-Gqlgen-Graphql/main/shared/utils"
)

// Mutation returns generated.MutationResolver implementation.
// func (r *Resolver) Mutation() generated.MutationResolver {
// 	return &accountResolver{r}
// }

// Mutation returns generated.MutationResolver implementation.
// func (r *Resolver) Query() generated.QueryResolver {
// 	return &queryResolver{r}
// }

type AccountResolver struct {
	// server *graphql.Server
	*Resolver
}

// type mutationResolver struct{ *Resolver }

// CreateUser is the resolver for the createUser field.
func (r *Resolver) Register(ctx context.Context, input model.Register) (*model.AccountResponse, error) {
	// Covert to protobuf to
	var registerInput accountv1.RegisterRequest
	if err := utils.Copy(&registerInput, &input); err != nil {
		return nil, err
	}

	// Connect to Account Service and try to get some feedback from hin
	register, err := r.account.Register(ctx, &registerInput)
	if err != nil {
		return nil, utils.FmtLogError(err)
	}

	// Convert result
	var accountResponse model.AccountResponse
	if err := utils.Copy(&accountResponse, &register); err != nil {
		return nil, err
	}
	return &accountResponse, nil
}

// Login is the resolver for check user credentials.
func (r *Resolver) Login(ctx context.Context, input model.Login) (*model.AccountResponse, error) {
	// Covert to protobuf to
	var loginInput accountv1.LoginRequest
	if err := utils.Copy(&loginInput, &input); err != nil {
		return nil, err
	}

	// Connect to Account Service and try to get some feedback from hin
	login, err := r.account.Login(ctx, &loginInput)
	if err != nil {
		return nil, utils.FmtLogError(err)
	}

	// Convert result
	var accountResponse model.AccountResponse
	if err := utils.Copy(&accountResponse, &login); err != nil {
		return nil, err
	}
	return &accountResponse, nil
}

// type queryResolver struct{ *Resolver }

// // User is the resolver for the users field.
// func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
// 	fmt.Println("Listing Users")
// 	var users []*model.User

// 	err := r.db.Find(&users).Error
// 	if err != nil {
// 		return nil, err
// 	}

// 	return users, nil
// }

// func getUserConnection(ctx context.Context) (net.Conn, error) {
// 	user_address, ok := os.LookupEnv("USER_SERVICE_ADDRESS")
// 	fmt.Println("user_address", user_address)
// 	if !ok {
// 		panic(fmt.Sprintf("no address specified for %s", user_address))
// 	}

// 	conn, err := net.Dial("tcp", user_address)
// 	if err != nil {
// 		fmt.Println("getUserConnection", err.Error())
// 		panic("")
// 	}
// 	fmt.Println("conn", conn)

// 	return conn, nil

// 	// var dialOpts []grpc.DialOption
// 	// dialOpts = append(dialOpts, grpc.WithTransportCredentials(insecure.NewCredentials()))

// 	// userServiceEndpoint, ok := os.LookupEnv("USER_SERVICE_ADDRESS")
// 	// if !ok {
// 	// 	logger.Panic(
// 	// 		"failed to find USER_SERVICE_ADDRESS environment variable",
// 	// 	)
// 	// }

// 	// conn, err := grpc.Dial(userServiceEndpoint, dialOpts...)
// 	// if err != nil {
// 	// 	return nil, fmt.Errorf("failed to connect to UserService. %s", err.Error())
// 	// }
// 	// return userv1.NewUserServiceClient(conn), nil
// }
