package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"fmt"

	"github.com/sandermendes/Go-Golang-Gorm-Postgres-Gqlgen-Graphql/main/microservices/graphql/helpers"
	"github.com/sandermendes/Go-Golang-Gorm-Postgres-Gqlgen-Graphql/main/microservices/graphql/model"
	accountv1 "github.com/sandermendes/Go-Golang-Gorm-Postgres-Gqlgen-Graphql/main/shared/protobufs/_generated/account/v1"
	"github.com/sandermendes/Go-Golang-Gorm-Postgres-Gqlgen-Graphql/main/shared/utils"
	"google.golang.org/protobuf/types/known/emptypb"
)

type AccountResolver struct {
	*Resolver
}

// type mutationResolver struct{ *Resolver }

// CreateUser is the resolver for the createUser field.
func (r *Resolver) Register(ctx context.Context, input model.Register) (*model.AccountResponse, error) {
	// Covert to protobuf to
	var registerInput accountv1.RegisterRequest
	if err := utils.Copy(&registerInput, &input); err != nil {
		return nil, err
	}

	// Connect to Account Service and try to get some feedback from hin
	register, err := r.accountConn.Register(ctx, &registerInput)
	if err != nil {
		return nil, fmt.Errorf(utils.FmtLogError(err))
	}

	// Convert result
	var accountResponse model.AccountResponse
	if err := utils.Copy(&accountResponse, &register); err != nil {
		return nil, err
	}
	return &accountResponse, nil
}

// Login is the resolver for check user credentials.
func (r *Resolver) Login(ctx context.Context, input model.Login) (*model.AccountResponse, error) {
	session := helpers.GetSession(ctx, "appSession")
	if session == nil {
		return nil, fmt.Errorf("fail to get session data")
	}

	// Check if already have session UserID
	if session.Values["userID"] != nil {
		// TODO: Improve session return
		return &model.AccountResponse{
			Token:    "already logged",
			Redirect: "/main",
		}, nil
	}

	// Covert to protobuf to
	var loginInput accountv1.LoginRequest
	if err := utils.Copy(&loginInput, &input); err != nil {
		return nil, err
	}

	// Connect to Account Service and try to get some feedback from hin
	login, err := r.accountConn.Login(ctx, &loginInput)
	if err != nil {
		return nil, fmt.Errorf(utils.FmtLogError(err))
	}

	subInfo, err := utils.ValidateToken(login.Token, "")
	if err != nil {
		// TODO: Improve error return
		fmt.Println(err)
		return nil, fmt.Errorf("error on parse login token data")
	}

	if subInfo == nil {
		return nil, fmt.Errorf("fail to retrive login token data")
	}

	// Set session userID
	session.Values["userID"] = subInfo.(string)
	if err := helpers.SaveSession(ctx, session); err != nil {
		return nil, fmt.Errorf("failed to save session, with error: %s", err)
	}

	// Convert result
	var loginResponse model.AccountResponse
	if err := utils.Copy(&loginResponse, &login); err != nil {
		return nil, err
	}
	// return &loginResponse, nil
	// TODO: Improve session return
	return &model.AccountResponse{
		Token:    "logged",
		Redirect: "/main",
	}, nil
}

// Logout delete de user current session
func (r *Resolver) Logout(ctx context.Context) (*bool, error) {
	vTrue := true
	vFalse := false
	// TODO: Implement some logs

	//
	session := helpers.DeleteSession(ctx, "appSession")
	if session == nil {
		return &vFalse, fmt.Errorf("fail to clean session")
	}

	// check if logged out
	if !session.IsNew {
		return &vTrue, nil
	}

	// not logged in
	return &vFalse, nil
}

// IsAuthed check if user is loggedin
func (r *Resolver) IsAuthed(ctx context.Context) (*bool, error) {
	vTrue := true
	vFalse := false

	session := helpers.GetSession(ctx, "appSession")
	if session == nil {
		return nil, fmt.Errorf("fail to get session data")
	}

	// Check if already have session UserID
	if session.Values["userID"] != nil {
		// TODO: Improve session return
		return &vTrue, nil
	}

	return &vFalse, nil
}

// Me return info about current user(logged user)
func (r *Resolver) Me(ctx context.Context) (*model.User, error) {
	// TODO: Implement some logs

	me, err := r.accountConn.Me(ctx, &emptypb.Empty{})
	if err != nil {
		// TODO: Improver error return
		return nil, fmt.Errorf(utils.FmtLogError(err))
	}

	var meResponse model.User
	if err := utils.Copy(&meResponse, &me); err != nil {
		// TODO: Improver error return
		return nil, err
	}
	return &meResponse, nil
}
